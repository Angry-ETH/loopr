{"version":3,"file":"static/js/679.fdc0b5b5.js","mappings":"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","sources":["../node_modules/@tanstack/query-core/src/utils.ts","../node_modules/@tanstack/query-core/src/notifyManager.ts","../node_modules/@tanstack/query-core/src/subscribable.ts","../node_modules/@tanstack/query-core/src/focusManager.ts","../node_modules/@tanstack/query-core/src/onlineManager.ts","../node_modules/@tanstack/query-core/src/retryer.ts","../node_modules/@tanstack/query-core/src/thenable.ts","../node_modules/@tanstack/query-core/src/removable.ts","../node_modules/@tanstack/query-core/src/query.ts","../node_modules/@tanstack/query-core/src/queryCache.ts","../node_modules/@tanstack/query-core/src/mutation.ts","../node_modules/@tanstack/query-core/src/mutationCache.ts","../node_modules/@tanstack/query-core/src/infiniteQueryBehavior.ts","../node_modules/@tanstack/query-core/src/queryClient.ts"],"sourcesContent":["import type {\n  DefaultError,\n  Enabled,\n  FetchStatus,\n  MutationKey,\n  MutationStatus,\n  QueryFunction,\n  QueryKey,\n  QueryOptions,\n  StaleTime,\n} from './types'\nimport type { Mutation } from './mutation'\nimport type { FetchOptions, Query } from './query'\n\n// TYPES\n\nexport interface QueryFilters<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  /**\n   * Filter to active queries, inactive queries or all queries\n   */\n  type?: QueryTypeFilter\n  /**\n   * Match query key exactly\n   */\n  exact?: boolean\n  /**\n   * Include queries matching this predicate function\n   */\n  predicate?: (query: Query<TQueryFnData, TError, TData, TQueryKey>) => boolean\n  /**\n   * Include queries matching this query key\n   */\n  queryKey?: TQueryKey\n  /**\n   * Include or exclude stale queries\n   */\n  stale?: boolean\n  /**\n   * Include queries matching their fetchStatus\n   */\n  fetchStatus?: FetchStatus\n}\n\nexport interface MutationFilters<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = unknown,\n  TContext = unknown,\n> {\n  /**\n   * Match mutation key exactly\n   */\n  exact?: boolean\n  /**\n   * Include mutations matching this predicate function\n   */\n  predicate?: (\n    mutation: Mutation<TData, TError, TVariables, TContext>,\n  ) => boolean\n  /**\n   * Include mutations matching this mutation key\n   */\n  mutationKey?: MutationKey\n  /**\n   * Filter by mutation status\n   */\n  status?: MutationStatus\n}\n\nexport type Updater<TInput, TOutput> = TOutput | ((input: TInput) => TOutput)\n\nexport type QueryTypeFilter = 'all' | 'active' | 'inactive'\n\n// UTILS\n\nexport const isServer = typeof window === 'undefined' || 'Deno' in globalThis\n\nexport function noop(): void\nexport function noop(): undefined\nexport function noop() {}\n\nexport function functionalUpdate<TInput, TOutput>(\n  updater: Updater<TInput, TOutput>,\n  input: TInput,\n): TOutput {\n  return typeof updater === 'function'\n    ? (updater as (_: TInput) => TOutput)(input)\n    : updater\n}\n\nexport function isValidTimeout(value: unknown): value is number {\n  return typeof value === 'number' && value >= 0 && value !== Infinity\n}\n\nexport function timeUntilStale(updatedAt: number, staleTime?: number): number {\n  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0)\n}\n\nexport function resolveStaleTime<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  staleTime: undefined | StaleTime<TQueryFnData, TError, TData, TQueryKey>,\n  query: Query<TQueryFnData, TError, TData, TQueryKey>,\n): number | undefined {\n  return typeof staleTime === 'function' ? staleTime(query) : staleTime\n}\n\nexport function resolveEnabled<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  enabled: undefined | Enabled<TQueryFnData, TError, TData, TQueryKey>,\n  query: Query<TQueryFnData, TError, TData, TQueryKey>,\n): boolean | undefined {\n  return typeof enabled === 'function' ? enabled(query) : enabled\n}\n\nexport function matchQuery(\n  filters: QueryFilters,\n  query: Query<any, any, any, any>,\n): boolean {\n  const {\n    type = 'all',\n    exact,\n    fetchStatus,\n    predicate,\n    queryKey,\n    stale,\n  } = filters\n\n  if (queryKey) {\n    if (exact) {\n      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {\n        return false\n      }\n    } else if (!partialMatchKey(query.queryKey, queryKey)) {\n      return false\n    }\n  }\n\n  if (type !== 'all') {\n    const isActive = query.isActive()\n    if (type === 'active' && !isActive) {\n      return false\n    }\n    if (type === 'inactive' && isActive) {\n      return false\n    }\n  }\n\n  if (typeof stale === 'boolean' && query.isStale() !== stale) {\n    return false\n  }\n\n  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {\n    return false\n  }\n\n  if (predicate && !predicate(query)) {\n    return false\n  }\n\n  return true\n}\n\nexport function matchMutation(\n  filters: MutationFilters,\n  mutation: Mutation<any, any>,\n): boolean {\n  const { exact, status, predicate, mutationKey } = filters\n  if (mutationKey) {\n    if (!mutation.options.mutationKey) {\n      return false\n    }\n    if (exact) {\n      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {\n        return false\n      }\n    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {\n      return false\n    }\n  }\n\n  if (status && mutation.state.status !== status) {\n    return false\n  }\n\n  if (predicate && !predicate(mutation)) {\n    return false\n  }\n\n  return true\n}\n\nexport function hashQueryKeyByOptions<TQueryKey extends QueryKey = QueryKey>(\n  queryKey: TQueryKey,\n  options?: Pick<QueryOptions<any, any, any, any>, 'queryKeyHashFn'>,\n): string {\n  const hashFn = options?.queryKeyHashFn || hashKey\n  return hashFn(queryKey)\n}\n\n/**\n * Default query & mutation keys hash function.\n * Hashes the value into a stable hash.\n */\nexport function hashKey(queryKey: QueryKey | MutationKey): string {\n  return JSON.stringify(queryKey, (_, val) =>\n    isPlainObject(val)\n      ? Object.keys(val)\n          .sort()\n          .reduce((result, key) => {\n            result[key] = val[key]\n            return result\n          }, {} as any)\n      : val,\n  )\n}\n\n/**\n * Checks if key `b` partially matches with key `a`.\n */\nexport function partialMatchKey(a: QueryKey, b: QueryKey): boolean\nexport function partialMatchKey(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    return Object.keys(b).every((key) => partialMatchKey(a[key], b[key]))\n  }\n\n  return false\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nexport function replaceEqualDeep<T>(a: unknown, b: T): T\nexport function replaceEqualDeep(a: any, b: any): any {\n  if (a === b) {\n    return a\n  }\n\n  const array = isPlainArray(a) && isPlainArray(b)\n\n  if (array || (isPlainObject(a) && isPlainObject(b))) {\n    const aItems = array ? a : Object.keys(a)\n    const aSize = aItems.length\n    const bItems = array ? b : Object.keys(b)\n    const bSize = bItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i]\n      if (\n        ((!array && aItems.includes(key)) || array) &&\n        a[key] === undefined &&\n        b[key] === undefined\n      ) {\n        copy[key] = undefined\n        equalItems++\n      } else {\n        copy[key] = replaceEqualDeep(a[key], b[key])\n        if (copy[key] === a[key] && a[key] !== undefined) {\n          equalItems++\n        }\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? a : copy\n  }\n\n  return b\n}\n\n/**\n * Shallow compare objects.\n */\nexport function shallowEqualObjects<T extends Record<string, any>>(\n  a: T,\n  b: T | undefined,\n): boolean {\n  if (!b || Object.keys(a).length !== Object.keys(b).length) {\n    return false\n  }\n\n  for (const key in a) {\n    if (a[key] !== b[key]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function isPlainArray(value: unknown) {\n  return Array.isArray(value) && value.length === Object.keys(value).length\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\n// eslint-disable-next-line @typescript-eslint/no-wrapper-object-types\nexport function isPlainObject(o: any): o is Object {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has no constructor\n  const ctor = o.constructor\n  if (ctor === undefined) {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Handles Objects created by Object.create(<arbitrary prototype>)\n  if (Object.getPrototypeOf(o) !== Object.prototype) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any): boolean {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function sleep(timeout: number): Promise<void> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, timeout)\n  })\n}\n\nexport function replaceData<\n  TData,\n  TOptions extends QueryOptions<any, any, any, any>,\n>(prevData: TData | undefined, data: TData, options: TOptions): TData {\n  if (typeof options.structuralSharing === 'function') {\n    return options.structuralSharing(prevData, data) as TData\n  } else if (options.structuralSharing !== false) {\n    if (process.env.NODE_ENV !== 'production') {\n      try {\n        return replaceEqualDeep(prevData, data)\n      } catch (error) {\n        console.error(\n          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${options.queryHash}]: ${error}`,\n        )\n\n        // Prevent the replaceEqualDeep from being called again down below.\n        throw error\n      }\n    }\n    // Structurally share data between prev and new data if needed\n    return replaceEqualDeep(prevData, data)\n  }\n  return data\n}\n\nexport function keepPreviousData<T>(\n  previousData: T | undefined,\n): T | undefined {\n  return previousData\n}\n\nexport function addToEnd<T>(items: Array<T>, item: T, max = 0): Array<T> {\n  const newItems = [...items, item]\n  return max && newItems.length > max ? newItems.slice(1) : newItems\n}\n\nexport function addToStart<T>(items: Array<T>, item: T, max = 0): Array<T> {\n  const newItems = [item, ...items]\n  return max && newItems.length > max ? newItems.slice(0, -1) : newItems\n}\n\nexport const skipToken = Symbol()\nexport type SkipToken = typeof skipToken\n\nexport function ensureQueryFn<\n  TQueryFnData = unknown,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  options: {\n    queryFn?: QueryFunction<TQueryFnData, TQueryKey> | SkipToken\n    queryHash?: string\n  },\n  fetchOptions?: FetchOptions<TQueryFnData>,\n): QueryFunction<TQueryFnData, TQueryKey> {\n  if (process.env.NODE_ENV !== 'production') {\n    if (options.queryFn === skipToken) {\n      console.error(\n        `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${options.queryHash}'`,\n      )\n    }\n  }\n\n  // if we attempt to retry a fetch that was triggered from an initialPromise\n  // when we don't have a queryFn yet, we can't retry, so we just return the already rejected initialPromise\n  // if an observer has already mounted, we will be able to retry with that queryFn\n  if (!options.queryFn && fetchOptions?.initialPromise) {\n    return () => fetchOptions.initialPromise!\n  }\n\n  if (!options.queryFn || options.queryFn === skipToken) {\n    return () =>\n      Promise.reject(new Error(`Missing queryFn: '${options.queryHash}'`))\n  }\n\n  return options.queryFn\n}\n","// TYPES\n\ntype NotifyCallback = () => void\n\ntype NotifyFunction = (callback: () => void) => void\n\ntype BatchNotifyFunction = (callback: () => void) => void\n\ntype BatchCallsCallback<T extends Array<unknown>> = (...args: T) => void\n\ntype ScheduleFunction = (callback: () => void) => void\n\nexport const defaultScheduler: ScheduleFunction = (cb) => setTimeout(cb, 0)\n\nexport function createNotifyManager() {\n  let queue: Array<NotifyCallback> = []\n  let transactions = 0\n  let notifyFn: NotifyFunction = (callback) => {\n    callback()\n  }\n  let batchNotifyFn: BatchNotifyFunction = (callback: () => void) => {\n    callback()\n  }\n  let scheduleFn = defaultScheduler\n\n  const schedule = (callback: NotifyCallback): void => {\n    if (transactions) {\n      queue.push(callback)\n    } else {\n      scheduleFn(() => {\n        notifyFn(callback)\n      })\n    }\n  }\n  const flush = (): void => {\n    const originalQueue = queue\n    queue = []\n    if (originalQueue.length) {\n      scheduleFn(() => {\n        batchNotifyFn(() => {\n          originalQueue.forEach((callback) => {\n            notifyFn(callback)\n          })\n        })\n      })\n    }\n  }\n\n  return {\n    batch: <T>(callback: () => T): T => {\n      let result\n      transactions++\n      try {\n        result = callback()\n      } finally {\n        transactions--\n        if (!transactions) {\n          flush()\n        }\n      }\n      return result\n    },\n    /**\n     * All calls to the wrapped function will be batched.\n     */\n    batchCalls: <T extends Array<unknown>>(\n      callback: BatchCallsCallback<T>,\n    ): BatchCallsCallback<T> => {\n      return (...args) => {\n        schedule(() => {\n          callback(...args)\n        })\n      }\n    },\n    schedule,\n    /**\n     * Use this method to set a custom notify function.\n     * This can be used to for example wrap notifications with `React.act` while running tests.\n     */\n    setNotifyFunction: (fn: NotifyFunction) => {\n      notifyFn = fn\n    },\n    /**\n     * Use this method to set a custom function to batch notifications together into a single tick.\n     * By default React Query will use the batch function provided by ReactDOM or React Native.\n     */\n    setBatchNotifyFunction: (fn: BatchNotifyFunction) => {\n      batchNotifyFn = fn\n    },\n    setScheduler: (fn: ScheduleFunction) => {\n      scheduleFn = fn\n    },\n  } as const\n}\n\n// SINGLETON\nexport const notifyManager = createNotifyManager()\n","export class Subscribable<TListener extends Function> {\n  protected listeners = new Set<TListener>()\n\n  constructor() {\n    this.subscribe = this.subscribe.bind(this)\n  }\n\n  subscribe(listener: TListener): () => void {\n    this.listeners.add(listener)\n\n    this.onSubscribe()\n\n    return () => {\n      this.listeners.delete(listener)\n      this.onUnsubscribe()\n    }\n  }\n\n  hasListeners(): boolean {\n    return this.listeners.size > 0\n  }\n\n  protected onSubscribe(): void {\n    // Do nothing\n  }\n\n  protected onUnsubscribe(): void {\n    // Do nothing\n  }\n}\n","import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype Listener = (focused: boolean) => void\n\ntype SetupFn = (\n  setFocused: (focused?: boolean) => void,\n) => (() => void) | undefined\n\nexport class FocusManager extends Subscribable<Listener> {\n  #focused?: boolean\n  #cleanup?: () => void\n\n  #setup: SetupFn\n\n  constructor() {\n    super()\n    this.#setup = (onFocus) => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const listener = () => onFocus()\n        // Listen to visibilitychange\n        window.addEventListener('visibilitychange', listener, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('visibilitychange', listener)\n        }\n      }\n      return\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.()\n      this.#cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.#setup = setup\n    this.#cleanup?.()\n    this.#cleanup = setup((focused) => {\n      if (typeof focused === 'boolean') {\n        this.setFocused(focused)\n      } else {\n        this.onFocus()\n      }\n    })\n  }\n\n  setFocused(focused?: boolean): void {\n    const changed = this.#focused !== focused\n    if (changed) {\n      this.#focused = focused\n      this.onFocus()\n    }\n  }\n\n  onFocus(): void {\n    const isFocused = this.isFocused()\n    this.listeners.forEach((listener) => {\n      listener(isFocused)\n    })\n  }\n\n  isFocused(): boolean {\n    if (typeof this.#focused === 'boolean') {\n      return this.#focused\n    }\n\n    // document global can be unavailable in react native\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    return globalThis.document?.visibilityState !== 'hidden'\n  }\n}\n\nexport const focusManager = new FocusManager()\n","import { Subscribable } from './subscribable'\nimport { isServer } from './utils'\n\ntype Listener = (online: boolean) => void\ntype SetupFn = (setOnline: Listener) => (() => void) | undefined\n\nexport class OnlineManager extends Subscribable<Listener> {\n  #online = true\n  #cleanup?: () => void\n\n  #setup: SetupFn\n\n  constructor() {\n    super()\n    this.#setup = (onOnline) => {\n      // addEventListener does not exist in React Native, but window does\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (!isServer && window.addEventListener) {\n        const onlineListener = () => onOnline(true)\n        const offlineListener = () => onOnline(false)\n        // Listen to online\n        window.addEventListener('online', onlineListener, false)\n        window.addEventListener('offline', offlineListener, false)\n\n        return () => {\n          // Be sure to unsubscribe if a new handler is set\n          window.removeEventListener('online', onlineListener)\n          window.removeEventListener('offline', offlineListener)\n        }\n      }\n\n      return\n    }\n  }\n\n  protected onSubscribe(): void {\n    if (!this.#cleanup) {\n      this.setEventListener(this.#setup)\n    }\n  }\n\n  protected onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#cleanup?.()\n      this.#cleanup = undefined\n    }\n  }\n\n  setEventListener(setup: SetupFn): void {\n    this.#setup = setup\n    this.#cleanup?.()\n    this.#cleanup = setup(this.setOnline.bind(this))\n  }\n\n  setOnline(online: boolean): void {\n    const changed = this.#online !== online\n\n    if (changed) {\n      this.#online = online\n      this.listeners.forEach((listener) => {\n        listener(online)\n      })\n    }\n  }\n\n  isOnline(): boolean {\n    return this.#online\n  }\n}\n\nexport const onlineManager = new OnlineManager()\n","import { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { pendingThenable } from './thenable'\nimport { isServer, sleep } from './utils'\nimport type { CancelOptions, DefaultError, NetworkMode } from './types'\n\n// TYPES\n\ninterface RetryerConfig<TData = unknown, TError = DefaultError> {\n  fn: () => TData | Promise<TData>\n  initialPromise?: Promise<TData>\n  abort?: () => void\n  onError?: (error: TError) => void\n  onSuccess?: (data: TData) => void\n  onFail?: (failureCount: number, error: TError) => void\n  onPause?: () => void\n  onContinue?: () => void\n  retry?: RetryValue<TError>\n  retryDelay?: RetryDelayValue<TError>\n  networkMode: NetworkMode | undefined\n  canRun: () => boolean\n}\n\nexport interface Retryer<TData = unknown> {\n  promise: Promise<TData>\n  cancel: (cancelOptions?: CancelOptions) => void\n  continue: () => Promise<unknown>\n  cancelRetry: () => void\n  continueRetry: () => void\n  canStart: () => boolean\n  start: () => Promise<TData>\n}\n\nexport type RetryValue<TError> = boolean | number | ShouldRetryFunction<TError>\n\ntype ShouldRetryFunction<TError = DefaultError> = (\n  failureCount: number,\n  error: TError,\n) => boolean\n\nexport type RetryDelayValue<TError> = number | RetryDelayFunction<TError>\n\ntype RetryDelayFunction<TError = DefaultError> = (\n  failureCount: number,\n  error: TError,\n) => number\n\nfunction defaultRetryDelay(failureCount: number) {\n  return Math.min(1000 * 2 ** failureCount, 30000)\n}\n\nexport function canFetch(networkMode: NetworkMode | undefined): boolean {\n  return (networkMode ?? 'online') === 'online'\n    ? onlineManager.isOnline()\n    : true\n}\n\nexport class CancelledError extends Error {\n  revert?: boolean\n  silent?: boolean\n  constructor(options?: CancelOptions) {\n    super('CancelledError')\n    this.revert = options?.revert\n    this.silent = options?.silent\n  }\n}\n\nexport function isCancelledError(value: any): value is CancelledError {\n  return value instanceof CancelledError\n}\n\nexport function createRetryer<TData = unknown, TError = DefaultError>(\n  config: RetryerConfig<TData, TError>,\n): Retryer<TData> {\n  let isRetryCancelled = false\n  let failureCount = 0\n  let isResolved = false\n  let continueFn: ((value?: unknown) => void) | undefined\n\n  const thenable = pendingThenable<TData>()\n\n  const cancel = (cancelOptions?: CancelOptions): void => {\n    if (!isResolved) {\n      reject(new CancelledError(cancelOptions))\n\n      config.abort?.()\n    }\n  }\n  const cancelRetry = () => {\n    isRetryCancelled = true\n  }\n\n  const continueRetry = () => {\n    isRetryCancelled = false\n  }\n\n  const canContinue = () =>\n    focusManager.isFocused() &&\n    (config.networkMode === 'always' || onlineManager.isOnline()) &&\n    config.canRun()\n\n  const canStart = () => canFetch(config.networkMode) && config.canRun()\n\n  const resolve = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onSuccess?.(value)\n      continueFn?.()\n      thenable.resolve(value)\n    }\n  }\n\n  const reject = (value: any) => {\n    if (!isResolved) {\n      isResolved = true\n      config.onError?.(value)\n      continueFn?.()\n      thenable.reject(value)\n    }\n  }\n\n  const pause = () => {\n    return new Promise((continueResolve) => {\n      continueFn = (value) => {\n        if (isResolved || canContinue()) {\n          continueResolve(value)\n        }\n      }\n      config.onPause?.()\n    }).then(() => {\n      continueFn = undefined\n      if (!isResolved) {\n        config.onContinue?.()\n      }\n    })\n  }\n\n  // Create loop function\n  const run = () => {\n    // Do nothing if already resolved\n    if (isResolved) {\n      return\n    }\n\n    let promiseOrValue: any\n\n    // we can re-use config.initialPromise on the first call of run()\n    const initialPromise =\n      failureCount === 0 ? config.initialPromise : undefined\n\n    // Execute query\n    try {\n      promiseOrValue = initialPromise ?? config.fn()\n    } catch (error) {\n      promiseOrValue = Promise.reject(error)\n    }\n\n    Promise.resolve(promiseOrValue)\n      .then(resolve)\n      .catch((error) => {\n        // Stop if the fetch is already resolved\n        if (isResolved) {\n          return\n        }\n\n        // Do we need to retry the request?\n        const retry = config.retry ?? (isServer ? 0 : 3)\n        const retryDelay = config.retryDelay ?? defaultRetryDelay\n        const delay =\n          typeof retryDelay === 'function'\n            ? retryDelay(failureCount, error)\n            : retryDelay\n        const shouldRetry =\n          retry === true ||\n          (typeof retry === 'number' && failureCount < retry) ||\n          (typeof retry === 'function' && retry(failureCount, error))\n\n        if (isRetryCancelled || !shouldRetry) {\n          // We are done if the query does not need to be retried\n          reject(error)\n          return\n        }\n\n        failureCount++\n\n        // Notify on fail\n        config.onFail?.(failureCount, error)\n\n        // Delay\n        sleep(delay)\n          // Pause if the document is not visible or when the device is offline\n          .then(() => {\n            return canContinue() ? undefined : pause()\n          })\n          .then(() => {\n            if (isRetryCancelled) {\n              reject(error)\n            } else {\n              run()\n            }\n          })\n      })\n  }\n\n  return {\n    promise: thenable,\n    cancel,\n    continue: () => {\n      continueFn?.()\n      return thenable\n    },\n    cancelRetry,\n    continueRetry,\n    canStart,\n    start: () => {\n      // Start loop\n      if (canStart()) {\n        run()\n      } else {\n        pause().then(run)\n      }\n      return thenable\n    },\n  }\n}\n","/**\n * Thenable types which matches React's types for promises\n *\n * React seemingly uses `.status`, `.value` and `.reason` properties on a promises to optimistically unwrap data from promises\n *\n * @see https://github.com/facebook/react/blob/main/packages/shared/ReactTypes.js#L112-L138\n * @see https://github.com/facebook/react/blob/4f604941569d2e8947ce1460a0b2997e835f37b9/packages/react-debug-tools/src/ReactDebugHooks.js#L224-L227\n */\n\ninterface Fulfilled<T> {\n  status: 'fulfilled'\n  value: T\n}\ninterface Rejected {\n  status: 'rejected'\n  reason: unknown\n}\ninterface Pending<T> {\n  status: 'pending'\n\n  /**\n   * Resolve the promise with a value.\n   * Will remove the `resolve` and `reject` properties from the promise.\n   */\n  resolve: (value: T) => void\n  /**\n   * Reject the promise with a reason.\n   * Will remove the `resolve` and `reject` properties from the promise.\n   */\n  reject: (reason: unknown) => void\n}\n\nexport type FulfilledThenable<T> = Promise<T> & Fulfilled<T>\nexport type RejectedThenable<T> = Promise<T> & Rejected\nexport type PendingThenable<T> = Promise<T> & Pending<T>\n\nexport type Thenable<T> =\n  | FulfilledThenable<T>\n  | RejectedThenable<T>\n  | PendingThenable<T>\n\nexport function pendingThenable<T>(): PendingThenable<T> {\n  let resolve: Pending<T>['resolve']\n  let reject: Pending<T>['reject']\n  // this could use `Promise.withResolvers()` in the future\n  const thenable = new Promise((_resolve, _reject) => {\n    resolve = _resolve\n    reject = _reject\n  }) as PendingThenable<T>\n\n  thenable.status = 'pending'\n  thenable.catch(() => {\n    // prevent unhandled rejection errors\n  })\n\n  function finalize(data: Fulfilled<T> | Rejected) {\n    Object.assign(thenable, data)\n\n    // clear pending props props to avoid calling them twice\n    delete (thenable as Partial<PendingThenable<T>>).resolve\n    delete (thenable as Partial<PendingThenable<T>>).reject\n  }\n\n  thenable.resolve = (value) => {\n    finalize({\n      status: 'fulfilled',\n      value,\n    })\n\n    resolve(value)\n  }\n  thenable.reject = (reason) => {\n    finalize({\n      status: 'rejected',\n      reason,\n    })\n\n    reject(reason)\n  }\n\n  return thenable\n}\n","import { isServer, isValidTimeout } from './utils'\n\nexport abstract class Removable {\n  gcTime!: number\n  #gcTimeout?: ReturnType<typeof setTimeout>\n\n  destroy(): void {\n    this.clearGcTimeout()\n  }\n\n  protected scheduleGc(): void {\n    this.clearGcTimeout()\n\n    if (isValidTimeout(this.gcTime)) {\n      this.#gcTimeout = setTimeout(() => {\n        this.optionalRemove()\n      }, this.gcTime)\n    }\n  }\n\n  protected updateGcTime(newGcTime: number | undefined): void {\n    // Default to 5 minutes (Infinity for server-side) if no gcTime is set\n    this.gcTime = Math.max(\n      this.gcTime || 0,\n      newGcTime ?? (isServer ? Infinity : 5 * 60 * 1000),\n    )\n  }\n\n  protected clearGcTimeout() {\n    if (this.#gcTimeout) {\n      clearTimeout(this.#gcTimeout)\n      this.#gcTimeout = undefined\n    }\n  }\n\n  protected abstract optionalRemove(): void\n}\n","import {\n  ensureQueryFn,\n  noop,\n  replaceData,\n  resolveEnabled,\n  skipToken,\n  timeUntilStale,\n} from './utils'\nimport { notifyManager } from './notifyManager'\nimport { canFetch, createRetryer, isCancelledError } from './retryer'\nimport { Removable } from './removable'\nimport type { QueryCache } from './queryCache'\nimport type { QueryClient } from './queryClient'\nimport type {\n  CancelOptions,\n  DefaultError,\n  FetchStatus,\n  InitialDataFunction,\n  OmitKeyof,\n  QueryFunction,\n  QueryFunctionContext,\n  QueryKey,\n  QueryMeta,\n  QueryOptions,\n  QueryStatus,\n  SetDataOptions,\n} from './types'\nimport type { QueryObserver } from './queryObserver'\nimport type { Retryer } from './retryer'\n\n// TYPES\n\ninterface QueryConfig<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  client: QueryClient\n  queryKey: TQueryKey\n  queryHash: string\n  options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state?: QueryState<TData, TError>\n}\n\nexport interface QueryState<TData = unknown, TError = DefaultError> {\n  data: TData | undefined\n  dataUpdateCount: number\n  dataUpdatedAt: number\n  error: TError | null\n  errorUpdateCount: number\n  errorUpdatedAt: number\n  fetchFailureCount: number\n  fetchFailureReason: TError | null\n  fetchMeta: FetchMeta | null\n  isInvalidated: boolean\n  status: QueryStatus\n  fetchStatus: FetchStatus\n}\n\nexport interface FetchContext<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  fetchFn: () => unknown | Promise<unknown>\n  fetchOptions?: FetchOptions\n  signal: AbortSignal\n  options: QueryOptions<TQueryFnData, TError, TData, any>\n  client: QueryClient\n  queryKey: TQueryKey\n  state: QueryState<TData, TError>\n}\n\nexport interface QueryBehavior<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  onFetch: (\n    context: FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n    query: Query,\n  ) => void\n}\n\nexport type FetchDirection = 'forward' | 'backward'\n\nexport interface FetchMeta {\n  fetchMore?: { direction: FetchDirection }\n}\n\nexport interface FetchOptions<TData = unknown> {\n  cancelRefetch?: boolean\n  meta?: FetchMeta\n  initialPromise?: Promise<TData>\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError\n}\n\ninterface FetchAction {\n  type: 'fetch'\n  meta?: FetchMeta\n}\n\ninterface SuccessAction<TData> {\n  data: TData | undefined\n  type: 'success'\n  dataUpdatedAt?: number\n  manual?: boolean\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: 'invalidate'\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError> {\n  type: 'setState'\n  state: Partial<QueryState<TData, TError>>\n  setStateOptions?: SetStateOptions\n}\n\nexport type Action<TData, TError> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | FetchAction\n  | InvalidateAction\n  | PauseAction\n  | SetStateAction<TData, TError>\n  | SuccessAction<TData>\n\nexport interface SetStateOptions {\n  meta?: any\n}\n\n// CLASS\n\nexport class Query<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Removable {\n  queryKey: TQueryKey\n  queryHash: string\n  options!: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state: QueryState<TData, TError>\n\n  #initialState: QueryState<TData, TError>\n  #revertState?: QueryState<TData, TError>\n  #cache: QueryCache\n  #client: QueryClient\n  #retryer?: Retryer<TData>\n  observers: Array<QueryObserver<any, any, any, any, any>>\n  #defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  #abortSignalConsumed: boolean\n\n  constructor(config: QueryConfig<TQueryFnData, TError, TData, TQueryKey>) {\n    super()\n\n    this.#abortSignalConsumed = false\n    this.#defaultOptions = config.defaultOptions\n    this.setOptions(config.options)\n    this.observers = []\n    this.#client = config.client\n    this.#cache = this.#client.getQueryCache()\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.#initialState = getDefaultState(this.options)\n    this.state = config.state ?? this.#initialState\n    this.scheduleGc()\n  }\n  get meta(): QueryMeta | undefined {\n    return this.options.meta\n  }\n\n  get promise(): Promise<TData> | undefined {\n    return this.#retryer?.promise\n  }\n\n  setOptions(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): void {\n    this.options = { ...this.#defaultOptions, ...options }\n\n    this.updateGcTime(this.options.gcTime)\n  }\n\n  protected optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === 'idle') {\n      this.#cache.remove(this)\n    }\n  }\n\n  setData(\n    newData: TData,\n    options?: SetDataOptions & { manual: boolean },\n  ): TData {\n    const data = replaceData(this.state.data, newData, this.options)\n\n    // Set data and mark it as cached\n    this.#dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual,\n    })\n\n    return data\n  }\n\n  setState(\n    state: Partial<QueryState<TData, TError>>,\n    setStateOptions?: SetStateOptions,\n  ): void {\n    this.#dispatch({ type: 'setState', state, setStateOptions })\n  }\n\n  cancel(options?: CancelOptions): Promise<void> {\n    const promise = this.#retryer?.promise\n    this.#retryer?.cancel(options)\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve()\n  }\n\n  destroy(): void {\n    super.destroy()\n\n    this.cancel({ silent: true })\n  }\n\n  reset(): void {\n    this.destroy()\n    this.setState(this.#initialState)\n  }\n\n  isActive(): boolean {\n    return this.observers.some(\n      (observer) => resolveEnabled(observer.options.enabled, this) !== false,\n    )\n  }\n\n  isDisabled(): boolean {\n    if (this.getObserversCount() > 0) {\n      return !this.isActive()\n    }\n    // if a query has no observers, it should still be considered disabled if it never attempted a fetch\n    return (\n      this.options.queryFn === skipToken ||\n      this.state.dataUpdateCount + this.state.errorUpdateCount === 0\n    )\n  }\n\n  isStale(): boolean {\n    if (this.state.isInvalidated) {\n      return true\n    }\n\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(\n        (observer) => observer.getCurrentResult().isStale,\n      )\n    }\n\n    return this.state.data === undefined\n  }\n\n  isStaleByTime(staleTime = 0): boolean {\n    return (\n      this.state.isInvalidated ||\n      this.state.data === undefined ||\n      !timeUntilStale(this.state.dataUpdatedAt, staleTime)\n    )\n  }\n\n  onFocus(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  onOnline(): void {\n    const observer = this.observers.find((x) => x.shouldFetchOnReconnect())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  addObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer)\n\n      // Stop the query from being garbage collected\n      this.clearGcTimeout()\n\n      this.#cache.notify({ type: 'observerAdded', query: this, observer })\n    }\n  }\n\n  removeObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter((x) => x !== observer)\n\n      if (!this.observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({ revert: true })\n          } else {\n            this.#retryer.cancelRetry()\n          }\n        }\n\n        this.scheduleGc()\n      }\n\n      this.#cache.notify({ type: 'observerRemoved', query: this, observer })\n    }\n  }\n\n  getObserversCount(): number {\n    return this.observers.length\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({ type: 'invalidate' })\n    }\n  }\n\n  fetch(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    fetchOptions?: FetchOptions<TQueryFnData>,\n  ): Promise<TData> {\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.data !== undefined && fetchOptions?.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetch\n        this.cancel({ silent: true })\n      } else if (this.#retryer) {\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        this.#retryer.continueRetry()\n        // Return current promise if we are already fetching\n        return this.#retryer.promise\n      }\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (options) {\n      this.setOptions(options)\n    }\n\n    // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n    if (!this.options.queryFn) {\n      const observer = this.observers.find((x) => x.options.queryFn)\n      if (observer) {\n        this.setOptions(observer.options)\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`,\n        )\n      }\n    }\n\n    const abortController = new AbortController()\n\n    // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n    const addSignalProperty = (object: unknown) => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true\n          return abortController.signal\n        },\n      })\n    }\n\n    // Create fetch function\n    const fetchFn = () => {\n      const queryFn = ensureQueryFn(this.options, fetchOptions)\n\n      // Create query function context\n      const queryFnContext: OmitKeyof<\n        QueryFunctionContext<TQueryKey>,\n        'signal'\n      > = {\n        client: this.#client,\n        queryKey: this.queryKey,\n        meta: this.meta,\n      }\n\n      addSignalProperty(queryFnContext)\n\n      this.#abortSignalConsumed = false\n      if (this.options.persister) {\n        return this.options.persister(\n          queryFn as QueryFunction<any>,\n          queryFnContext as QueryFunctionContext<TQueryKey>,\n          this as unknown as Query,\n        )\n      }\n\n      return queryFn(queryFnContext as QueryFunctionContext<TQueryKey>)\n    }\n\n    // Trigger behavior hook\n    const context: OmitKeyof<\n      FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n      'signal'\n    > = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      client: this.#client,\n      state: this.state,\n      fetchFn,\n    }\n\n    addSignalProperty(context)\n\n    this.options.behavior?.onFetch(\n      context as FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n      this as unknown as Query,\n    )\n\n    // Store state in case the current fetch needs to be reverted\n    this.#revertState = this.state\n\n    // Set to fetching state if not already in it\n    if (\n      this.state.fetchStatus === 'idle' ||\n      this.state.fetchMeta !== context.fetchOptions?.meta\n    ) {\n      this.#dispatch({ type: 'fetch', meta: context.fetchOptions?.meta })\n    }\n\n    const onError = (error: TError | { silent?: boolean }) => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.#dispatch({\n          type: 'error',\n          error: error as TError,\n        })\n      }\n\n      if (!isCancelledError(error)) {\n        // Notify cache callback\n        this.#cache.config.onError?.(\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n        this.#cache.config.onSettled?.(\n          this.state.data,\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n      }\n\n      // Schedule query gc after fetching\n      this.scheduleGc()\n    }\n\n    // Try to fetch the data\n    this.#retryer = createRetryer({\n      initialPromise: fetchOptions?.initialPromise as\n        | Promise<TData>\n        | undefined,\n      fn: context.fetchFn as () => Promise<TData>,\n      abort: abortController.abort.bind(abortController),\n      onSuccess: (data) => {\n        if (data === undefined) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.error(\n              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`,\n            )\n          }\n          onError(new Error(`${this.queryHash} data is undefined`) as any)\n          return\n        }\n\n        try {\n          this.setData(data)\n        } catch (error) {\n          onError(error as TError)\n          return\n        }\n\n        // Notify cache callback\n        this.#cache.config.onSuccess?.(data, this as Query<any, any, any, any>)\n        this.#cache.config.onSettled?.(\n          data,\n          this.state.error as any,\n          this as Query<any, any, any, any>,\n        )\n\n        // Schedule query gc after fetching\n        this.scheduleGc()\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: 'failed', failureCount, error })\n      },\n      onPause: () => {\n        this.#dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.#dispatch({ type: 'continue' })\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n      canRun: () => true,\n    })\n\n    return this.#retryer.start()\n  }\n\n  #dispatch(action: Action<TData, TError>): void {\n    const reducer = (\n      state: QueryState<TData, TError>,\n    ): QueryState<TData, TError> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            fetchStatus: 'paused',\n          }\n        case 'continue':\n          return {\n            ...state,\n            fetchStatus: 'fetching',\n          }\n        case 'fetch':\n          return {\n            ...state,\n            ...fetchState(state.data, this.options),\n            fetchMeta: action.meta ?? null,\n          }\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null,\n            }),\n          }\n        case 'error':\n          const error = action.error\n\n          if (isCancelledError(error) && error.revert && this.#revertState) {\n            return { ...this.#revertState, fetchStatus: 'idle' }\n          }\n\n          return {\n            ...state,\n            error,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error,\n            fetchStatus: 'idle',\n            status: 'error',\n          }\n        case 'invalidate':\n          return {\n            ...state,\n            isInvalidated: true,\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.observers.forEach((observer) => {\n        observer.onQueryUpdate()\n      })\n\n      this.#cache.notify({ query: this, type: 'updated', action })\n    })\n  }\n}\n\nexport function fetchState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  data: TData | undefined,\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n) {\n  return {\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: canFetch(options.networkMode) ? 'fetching' : 'paused',\n    ...(data === undefined &&\n      ({\n        error: null,\n        status: 'pending',\n      } as const)),\n  } as const\n}\n\nfunction getDefaultState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): QueryState<TData, TError> {\n  const data =\n    typeof options.initialData === 'function'\n      ? (options.initialData as InitialDataFunction<TData>)()\n      : options.initialData\n\n  const hasData = data !== undefined\n\n  const initialDataUpdatedAt = hasData\n    ? typeof options.initialDataUpdatedAt === 'function'\n      ? (options.initialDataUpdatedAt as () => number | undefined)()\n      : options.initialDataUpdatedAt\n    : 0\n\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? (initialDataUpdatedAt ?? Date.now()) : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'pending',\n    fetchStatus: 'idle',\n  }\n}\n","import { hashQueryKeyByOptions, matchQuery } from './utils'\nimport { Query } from './query'\nimport { notifyManager } from './notifyManager'\nimport { Subscribable } from './subscribable'\nimport type { QueryFilters } from './utils'\nimport type { Action, QueryState } from './query'\nimport type {\n  DefaultError,\n  NotifyEvent,\n  QueryKey,\n  QueryOptions,\n  WithRequired,\n} from './types'\nimport type { QueryClient } from './queryClient'\nimport type { QueryObserver } from './queryObserver'\n\n// TYPES\n\ninterface QueryCacheConfig {\n  onError?: (\n    error: DefaultError,\n    query: Query<unknown, unknown, unknown>,\n  ) => void\n  onSuccess?: (data: unknown, query: Query<unknown, unknown, unknown>) => void\n  onSettled?: (\n    data: unknown | undefined,\n    error: DefaultError | null,\n    query: Query<unknown, unknown, unknown>,\n  ) => void\n}\n\ninterface NotifyEventQueryAdded extends NotifyEvent {\n  type: 'added'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryRemoved extends NotifyEvent {\n  type: 'removed'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryUpdated extends NotifyEvent {\n  type: 'updated'\n  query: Query<any, any, any, any>\n  action: Action<any, any>\n}\n\ninterface NotifyEventQueryObserverAdded extends NotifyEvent {\n  type: 'observerAdded'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverRemoved extends NotifyEvent {\n  type: 'observerRemoved'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverResultsUpdated extends NotifyEvent {\n  type: 'observerResultsUpdated'\n  query: Query<any, any, any, any>\n}\n\ninterface NotifyEventQueryObserverOptionsUpdated extends NotifyEvent {\n  type: 'observerOptionsUpdated'\n  query: Query<any, any, any, any>\n  observer: QueryObserver<any, any, any, any, any>\n}\n\nexport type QueryCacheNotifyEvent =\n  | NotifyEventQueryAdded\n  | NotifyEventQueryRemoved\n  | NotifyEventQueryUpdated\n  | NotifyEventQueryObserverAdded\n  | NotifyEventQueryObserverRemoved\n  | NotifyEventQueryObserverResultsUpdated\n  | NotifyEventQueryObserverOptionsUpdated\n\ntype QueryCacheListener = (event: QueryCacheNotifyEvent) => void\n\nexport interface QueryStore {\n  has: (queryHash: string) => boolean\n  set: (queryHash: string, query: Query) => void\n  get: (queryHash: string) => Query | undefined\n  delete: (queryHash: string) => void\n  values: () => IterableIterator<Query>\n}\n\n// CLASS\n\nexport class QueryCache extends Subscribable<QueryCacheListener> {\n  #queries: QueryStore\n\n  constructor(public config: QueryCacheConfig = {}) {\n    super()\n    this.#queries = new Map<string, Query>()\n  }\n\n  build<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    client: QueryClient,\n    options: WithRequired<\n      QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n      'queryKey'\n    >,\n    state?: QueryState<TData, TError>,\n  ): Query<TQueryFnData, TError, TData, TQueryKey> {\n    const queryKey = options.queryKey\n    const queryHash =\n      options.queryHash ?? hashQueryKeyByOptions(queryKey, options)\n    let query = this.get<TQueryFnData, TError, TData, TQueryKey>(queryHash)\n\n    if (!query) {\n      query = new Query({\n        client,\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey),\n      })\n      this.add(query)\n    }\n\n    return query\n  }\n\n  add(query: Query<any, any, any, any>): void {\n    if (!this.#queries.has(query.queryHash)) {\n      this.#queries.set(query.queryHash, query)\n\n      this.notify({\n        type: 'added',\n        query,\n      })\n    }\n  }\n\n  remove(query: Query<any, any, any, any>): void {\n    const queryInMap = this.#queries.get(query.queryHash)\n\n    if (queryInMap) {\n      query.destroy()\n\n      if (queryInMap === query) {\n        this.#queries.delete(query.queryHash)\n      }\n\n      this.notify({ type: 'removed', query })\n    }\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        this.remove(query)\n      })\n    })\n  }\n\n  get<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    queryHash: string,\n  ): Query<TQueryFnData, TError, TData, TQueryKey> | undefined {\n    return this.#queries.get(queryHash) as\n      | Query<TQueryFnData, TError, TData, TQueryKey>\n      | undefined\n  }\n\n  getAll(): Array<Query> {\n    return [...this.#queries.values()]\n  }\n\n  find<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData>(\n    filters: WithRequired<QueryFilters, 'queryKey'>,\n  ): Query<TQueryFnData, TError, TData> | undefined {\n    const defaultedFilters = { exact: true, ...filters }\n\n    return this.getAll().find((query) =>\n      matchQuery(defaultedFilters, query),\n    ) as Query<TQueryFnData, TError, TData> | undefined\n  }\n\n  findAll(filters: QueryFilters<any, any, any, any> = {}): Array<Query> {\n    const queries = this.getAll()\n    return Object.keys(filters).length > 0\n      ? queries.filter((query) => matchQuery(filters, query))\n      : queries\n  }\n\n  notify(event: QueryCacheNotifyEvent): void {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event)\n      })\n    })\n  }\n\n  onFocus(): void {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onFocus()\n      })\n    })\n  }\n\n  onOnline(): void {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onOnline()\n      })\n    })\n  }\n}\n","import { notifyManager } from './notifyManager'\nimport { Removable } from './removable'\nimport { createRetryer } from './retryer'\nimport type {\n  DefaultError,\n  MutationMeta,\n  MutationOptions,\n  MutationStatus,\n} from './types'\nimport type { MutationCache } from './mutationCache'\nimport type { MutationObserver } from './mutationObserver'\nimport type { Retryer } from './retryer'\n\n// TYPES\n\ninterface MutationConfig<TData, TError, TVariables, TContext> {\n  mutationId: number\n  mutationCache: MutationCache\n  options: MutationOptions<TData, TError, TVariables, TContext>\n  state?: MutationState<TData, TError, TVariables, TContext>\n}\n\nexport interface MutationState<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = unknown,\n  TContext = unknown,\n> {\n  context: TContext | undefined\n  data: TData | undefined\n  error: TError | null\n  failureCount: number\n  failureReason: TError | null\n  isPaused: boolean\n  status: MutationStatus\n  variables: TVariables | undefined\n  submittedAt: number\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError | null\n}\n\ninterface PendingAction<TVariables, TContext> {\n  type: 'pending'\n  isPaused: boolean\n  variables?: TVariables\n  context?: TContext\n}\n\ninterface SuccessAction<TData> {\n  type: 'success'\n  data: TData\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\nexport type Action<TData, TError, TVariables, TContext> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | PendingAction<TVariables, TContext>\n  | PauseAction\n  | SuccessAction<TData>\n\n// CLASS\n\nexport class Mutation<\n  TData = unknown,\n  TError = DefaultError,\n  TVariables = unknown,\n  TContext = unknown,\n> extends Removable {\n  state: MutationState<TData, TError, TVariables, TContext>\n  options!: MutationOptions<TData, TError, TVariables, TContext>\n  readonly mutationId: number\n\n  #observers: Array<MutationObserver<TData, TError, TVariables, TContext>>\n  #mutationCache: MutationCache\n  #retryer?: Retryer<TData>\n\n  constructor(config: MutationConfig<TData, TError, TVariables, TContext>) {\n    super()\n\n    this.mutationId = config.mutationId\n    this.#mutationCache = config.mutationCache\n    this.#observers = []\n    this.state = config.state || getDefaultState()\n\n    this.setOptions(config.options)\n    this.scheduleGc()\n  }\n\n  setOptions(\n    options: MutationOptions<TData, TError, TVariables, TContext>,\n  ): void {\n    this.options = options\n\n    this.updateGcTime(this.options.gcTime)\n  }\n\n  get meta(): MutationMeta | undefined {\n    return this.options.meta\n  }\n\n  addObserver(observer: MutationObserver<any, any, any, any>): void {\n    if (!this.#observers.includes(observer)) {\n      this.#observers.push(observer)\n\n      // Stop the mutation from being garbage collected\n      this.clearGcTimeout()\n\n      this.#mutationCache.notify({\n        type: 'observerAdded',\n        mutation: this,\n        observer,\n      })\n    }\n  }\n\n  removeObserver(observer: MutationObserver<any, any, any, any>): void {\n    this.#observers = this.#observers.filter((x) => x !== observer)\n\n    this.scheduleGc()\n\n    this.#mutationCache.notify({\n      type: 'observerRemoved',\n      mutation: this,\n      observer,\n    })\n  }\n\n  protected optionalRemove() {\n    if (!this.#observers.length) {\n      if (this.state.status === 'pending') {\n        this.scheduleGc()\n      } else {\n        this.#mutationCache.remove(this)\n      }\n    }\n  }\n\n  continue(): Promise<unknown> {\n    return (\n      this.#retryer?.continue() ??\n      // continuing a mutation assumes that variables are set, mutation must have been dehydrated before\n      this.execute(this.state.variables!)\n    )\n  }\n\n  async execute(variables: TVariables): Promise<TData> {\n    this.#retryer = createRetryer({\n      fn: () => {\n        if (!this.options.mutationFn) {\n          return Promise.reject(new Error('No mutationFn found'))\n        }\n        return this.options.mutationFn(variables)\n      },\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: 'failed', failureCount, error })\n      },\n      onPause: () => {\n        this.#dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.#dispatch({ type: 'continue' })\n      },\n      retry: this.options.retry ?? 0,\n      retryDelay: this.options.retryDelay,\n      networkMode: this.options.networkMode,\n      canRun: () => this.#mutationCache.canRun(this),\n    })\n\n    const restored = this.state.status === 'pending'\n    const isPaused = !this.#retryer.canStart()\n\n    try {\n      if (!restored) {\n        this.#dispatch({ type: 'pending', variables, isPaused })\n        // Notify cache callback\n        await this.#mutationCache.config.onMutate?.(\n          variables,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n        const context = await this.options.onMutate?.(variables)\n        if (context !== this.state.context) {\n          this.#dispatch({\n            type: 'pending',\n            context,\n            variables,\n            isPaused,\n          })\n        }\n      }\n      const data = await this.#retryer.start()\n\n      // Notify cache callback\n      await this.#mutationCache.config.onSuccess?.(\n        data,\n        variables,\n        this.state.context,\n        this as Mutation<unknown, unknown, unknown, unknown>,\n      )\n\n      await this.options.onSuccess?.(data, variables, this.state.context!)\n\n      // Notify cache callback\n      await this.#mutationCache.config.onSettled?.(\n        data,\n        null,\n        this.state.variables,\n        this.state.context,\n        this as Mutation<unknown, unknown, unknown, unknown>,\n      )\n\n      await this.options.onSettled?.(data, null, variables, this.state.context)\n\n      this.#dispatch({ type: 'success', data })\n      return data\n    } catch (error) {\n      try {\n        // Notify cache callback\n        await this.#mutationCache.config.onError?.(\n          error as any,\n          variables,\n          this.state.context,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n\n        await this.options.onError?.(\n          error as TError,\n          variables,\n          this.state.context,\n        )\n\n        // Notify cache callback\n        await this.#mutationCache.config.onSettled?.(\n          undefined,\n          error as any,\n          this.state.variables,\n          this.state.context,\n          this as Mutation<unknown, unknown, unknown, unknown>,\n        )\n\n        await this.options.onSettled?.(\n          undefined,\n          error as TError,\n          variables,\n          this.state.context,\n        )\n        throw error\n      } finally {\n        this.#dispatch({ type: 'error', error: error as TError })\n      }\n    } finally {\n      this.#mutationCache.runNext(this)\n    }\n  }\n\n  #dispatch(action: Action<TData, TError, TVariables, TContext>): void {\n    const reducer = (\n      state: MutationState<TData, TError, TVariables, TContext>,\n    ): MutationState<TData, TError, TVariables, TContext> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            failureCount: action.failureCount,\n            failureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            isPaused: true,\n          }\n        case 'continue':\n          return {\n            ...state,\n            isPaused: false,\n          }\n        case 'pending':\n          return {\n            ...state,\n            context: action.context,\n            data: undefined,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            isPaused: action.isPaused,\n            status: 'pending',\n            variables: action.variables,\n            submittedAt: Date.now(),\n          }\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            failureCount: 0,\n            failureReason: null,\n            error: null,\n            status: 'success',\n            isPaused: false,\n          }\n        case 'error':\n          return {\n            ...state,\n            data: undefined,\n            error: action.error,\n            failureCount: state.failureCount + 1,\n            failureReason: action.error,\n            isPaused: false,\n            status: 'error',\n          }\n      }\n    }\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.#observers.forEach((observer) => {\n        observer.onMutationUpdate(action)\n      })\n      this.#mutationCache.notify({\n        mutation: this,\n        type: 'updated',\n        action,\n      })\n    })\n  }\n}\n\nexport function getDefaultState<\n  TData,\n  TError,\n  TVariables,\n  TContext,\n>(): MutationState<TData, TError, TVariables, TContext> {\n  return {\n    context: undefined,\n    data: undefined,\n    error: null,\n    failureCount: 0,\n    failureReason: null,\n    isPaused: false,\n    status: 'idle',\n    variables: undefined,\n    submittedAt: 0,\n  }\n}\n","import { notifyManager } from './notifyManager'\nimport { Mutation } from './mutation'\nimport { matchMutation, noop } from './utils'\nimport { Subscribable } from './subscribable'\nimport type { MutationObserver } from './mutationObserver'\nimport type { DefaultError, MutationOptions, NotifyEvent } from './types'\nimport type { QueryClient } from './queryClient'\nimport type { Action, MutationState } from './mutation'\nimport type { MutationFilters } from './utils'\n\n// TYPES\n\ninterface MutationCacheConfig {\n  onError?: (\n    error: DefaultError,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onSuccess?: (\n    data: unknown,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onMutate?: (\n    variables: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n  onSettled?: (\n    data: unknown | undefined,\n    error: DefaultError | null,\n    variables: unknown,\n    context: unknown,\n    mutation: Mutation<unknown, unknown, unknown>,\n  ) => Promise<unknown> | unknown\n}\n\ninterface NotifyEventMutationAdded extends NotifyEvent {\n  type: 'added'\n  mutation: Mutation<any, any, any, any>\n}\ninterface NotifyEventMutationRemoved extends NotifyEvent {\n  type: 'removed'\n  mutation: Mutation<any, any, any, any>\n}\n\ninterface NotifyEventMutationObserverAdded extends NotifyEvent {\n  type: 'observerAdded'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverRemoved extends NotifyEvent {\n  type: 'observerRemoved'\n  mutation: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any>\n}\n\ninterface NotifyEventMutationObserverOptionsUpdated extends NotifyEvent {\n  type: 'observerOptionsUpdated'\n  mutation?: Mutation<any, any, any, any>\n  observer: MutationObserver<any, any, any, any>\n}\n\ninterface NotifyEventMutationUpdated extends NotifyEvent {\n  type: 'updated'\n  mutation: Mutation<any, any, any, any>\n  action: Action<any, any, any, any>\n}\n\nexport type MutationCacheNotifyEvent =\n  | NotifyEventMutationAdded\n  | NotifyEventMutationRemoved\n  | NotifyEventMutationObserverAdded\n  | NotifyEventMutationObserverRemoved\n  | NotifyEventMutationObserverOptionsUpdated\n  | NotifyEventMutationUpdated\n\ntype MutationCacheListener = (event: MutationCacheNotifyEvent) => void\n\n// CLASS\n\nexport class MutationCache extends Subscribable<MutationCacheListener> {\n  #mutations: Set<Mutation<any, any, any, any>>\n  #scopes: Map<string, Array<Mutation<any, any, any, any>>>\n  #mutationId: number\n\n  constructor(public config: MutationCacheConfig = {}) {\n    super()\n    this.#mutations = new Set()\n    this.#scopes = new Map()\n    this.#mutationId = 0\n  }\n\n  build<TData, TError, TVariables, TContext>(\n    client: QueryClient,\n    options: MutationOptions<TData, TError, TVariables, TContext>,\n    state?: MutationState<TData, TError, TVariables, TContext>,\n  ): Mutation<TData, TError, TVariables, TContext> {\n    const mutation = new Mutation({\n      mutationCache: this,\n      mutationId: ++this.#mutationId,\n      options: client.defaultMutationOptions(options),\n      state,\n    })\n\n    this.add(mutation)\n\n    return mutation\n  }\n\n  add(mutation: Mutation<any, any, any, any>): void {\n    this.#mutations.add(mutation)\n    const scope = scopeFor(mutation)\n    if (typeof scope === 'string') {\n      const scopedMutations = this.#scopes.get(scope)\n      if (scopedMutations) {\n        scopedMutations.push(mutation)\n      } else {\n        this.#scopes.set(scope, [mutation])\n      }\n    }\n    this.notify({ type: 'added', mutation })\n  }\n\n  remove(mutation: Mutation<any, any, any, any>): void {\n    if (this.#mutations.delete(mutation)) {\n      const scope = scopeFor(mutation)\n      if (typeof scope === 'string') {\n        const scopedMutations = this.#scopes.get(scope)\n        if (scopedMutations) {\n          if (scopedMutations.length > 1) {\n            const index = scopedMutations.indexOf(mutation)\n            if (index !== -1) {\n              scopedMutations.splice(index, 1)\n            }\n          } else if (scopedMutations[0] === mutation) {\n            this.#scopes.delete(scope)\n          }\n        }\n      }\n    }\n\n    // Currently we notify the removal even if the mutation was already removed.\n    // Consider making this an error or not notifying of the removal depending on the desired semantics.\n    this.notify({ type: 'removed', mutation })\n  }\n\n  canRun(mutation: Mutation<any, any, any, any>): boolean {\n    const scope = scopeFor(mutation)\n    if (typeof scope === 'string') {\n      const mutationsWithSameScope = this.#scopes.get(scope)\n      const firstPendingMutation = mutationsWithSameScope?.find(\n        (m) => m.state.status === 'pending',\n      )\n      // we can run if there is no current pending mutation (start use-case)\n      // or if WE are the first pending mutation (continue use-case)\n      return !firstPendingMutation || firstPendingMutation === mutation\n    } else {\n      // For unscoped mutations there are never any pending mutations in front of the\n      // current mutation\n      return true\n    }\n  }\n\n  runNext(mutation: Mutation<any, any, any, any>): Promise<unknown> {\n    const scope = scopeFor(mutation)\n    if (typeof scope === 'string') {\n      const foundMutation = this.#scopes\n        .get(scope)\n        ?.find((m) => m !== mutation && m.state.isPaused)\n\n      return foundMutation?.continue() ?? Promise.resolve()\n    } else {\n      return Promise.resolve()\n    }\n  }\n\n  clear(): void {\n    notifyManager.batch(() => {\n      this.#mutations.forEach((mutation) => {\n        this.notify({ type: 'removed', mutation })\n      })\n      this.#mutations.clear()\n      this.#scopes.clear()\n    })\n  }\n\n  getAll(): Array<Mutation> {\n    return Array.from(this.#mutations)\n  }\n\n  find<\n    TData = unknown,\n    TError = DefaultError,\n    TVariables = any,\n    TContext = unknown,\n  >(\n    filters: MutationFilters,\n  ): Mutation<TData, TError, TVariables, TContext> | undefined {\n    const defaultedFilters = { exact: true, ...filters }\n\n    return this.getAll().find((mutation) =>\n      matchMutation(defaultedFilters, mutation),\n    ) as Mutation<TData, TError, TVariables, TContext> | undefined\n  }\n\n  findAll(filters: MutationFilters = {}): Array<Mutation> {\n    return this.getAll().filter((mutation) => matchMutation(filters, mutation))\n  }\n\n  notify(event: MutationCacheNotifyEvent) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event)\n      })\n    })\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    const pausedMutations = this.getAll().filter((x) => x.state.isPaused)\n\n    return notifyManager.batch(() =>\n      Promise.all(\n        pausedMutations.map((mutation) => mutation.continue().catch(noop)),\n      ),\n    )\n  }\n}\n\nfunction scopeFor(mutation: Mutation<any, any, any, any>) {\n  return mutation.options.scope?.id\n}\n","import { addToEnd, addToStart, ensureQueryFn } from './utils'\nimport type { QueryBehavior } from './query'\nimport type {\n  InfiniteData,\n  InfiniteQueryPageParamsOptions,\n  OmitKeyof,\n  QueryFunctionContext,\n  QueryKey,\n} from './types'\n\nexport function infiniteQueryBehavior<TQueryFnData, TError, TData, TPageParam>(\n  pages?: number,\n): QueryBehavior<TQueryFnData, TError, InfiniteData<TData, TPageParam>> {\n  return {\n    onFetch: (context, query) => {\n      const options = context.options as InfiniteQueryPageParamsOptions<TData>\n      const direction = context.fetchOptions?.meta?.fetchMore?.direction\n      const oldPages = context.state.data?.pages || []\n      const oldPageParams = context.state.data?.pageParams || []\n      let result: InfiniteData<unknown> = { pages: [], pageParams: [] }\n      let currentPage = 0\n\n      const fetchFn = async () => {\n        let cancelled = false\n        const addSignalProperty = (object: unknown) => {\n          Object.defineProperty(object, 'signal', {\n            enumerable: true,\n            get: () => {\n              if (context.signal.aborted) {\n                cancelled = true\n              } else {\n                context.signal.addEventListener('abort', () => {\n                  cancelled = true\n                })\n              }\n              return context.signal\n            },\n          })\n        }\n\n        const queryFn = ensureQueryFn(context.options, context.fetchOptions)\n\n        // Create function to fetch a page\n        const fetchPage = async (\n          data: InfiniteData<unknown>,\n          param: unknown,\n          previous?: boolean,\n        ): Promise<InfiniteData<unknown>> => {\n          if (cancelled) {\n            return Promise.reject()\n          }\n\n          if (param == null && data.pages.length) {\n            return Promise.resolve(data)\n          }\n\n          const queryFnContext: OmitKeyof<\n            QueryFunctionContext<QueryKey, unknown>,\n            'signal'\n          > = {\n            client: context.client,\n            queryKey: context.queryKey,\n            pageParam: param,\n            direction: previous ? 'backward' : 'forward',\n            meta: context.options.meta,\n          }\n\n          addSignalProperty(queryFnContext)\n\n          const page = await queryFn(\n            queryFnContext as QueryFunctionContext<QueryKey, unknown>,\n          )\n\n          const { maxPages } = context.options\n          const addTo = previous ? addToStart : addToEnd\n\n          return {\n            pages: addTo(data.pages, page, maxPages),\n            pageParams: addTo(data.pageParams, param, maxPages),\n          }\n        }\n\n        // fetch next / previous page?\n        if (direction && oldPages.length) {\n          const previous = direction === 'backward'\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam\n          const oldData = {\n            pages: oldPages,\n            pageParams: oldPageParams,\n          }\n          const param = pageParamFn(options, oldData)\n\n          result = await fetchPage(oldData, param, previous)\n        } else {\n          const remainingPages = pages ?? oldPages.length\n\n          // Fetch all pages\n          do {\n            const param =\n              currentPage === 0\n                ? (oldPageParams[0] ?? options.initialPageParam)\n                : getNextPageParam(options, result)\n            if (currentPage > 0 && param == null) {\n              break\n            }\n            result = await fetchPage(result, param)\n            currentPage++\n          } while (currentPage < remainingPages)\n        }\n\n        return result\n      }\n      if (context.options.persister) {\n        context.fetchFn = () => {\n          return context.options.persister?.(\n            fetchFn as any,\n            {\n              client: context.client,\n              queryKey: context.queryKey,\n              meta: context.options.meta,\n              signal: context.signal,\n            },\n            query,\n          )\n        }\n      } else {\n        context.fetchFn = fetchFn\n      }\n    },\n  }\n}\n\nfunction getNextPageParam(\n  options: InfiniteQueryPageParamsOptions<any>,\n  { pages, pageParams }: InfiniteData<unknown>,\n): unknown | undefined {\n  const lastIndex = pages.length - 1\n  return pages.length > 0\n    ? options.getNextPageParam(\n        pages[lastIndex],\n        pages,\n        pageParams[lastIndex],\n        pageParams,\n      )\n    : undefined\n}\n\nfunction getPreviousPageParam(\n  options: InfiniteQueryPageParamsOptions<any>,\n  { pages, pageParams }: InfiniteData<unknown>,\n): unknown | undefined {\n  return pages.length > 0\n    ? options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams)\n    : undefined\n}\n\n/**\n * Checks if there is a next page.\n */\nexport function hasNextPage(\n  options: InfiniteQueryPageParamsOptions<any, any>,\n  data?: InfiniteData<unknown>,\n): boolean {\n  if (!data) return false\n  return getNextPageParam(options, data) != null\n}\n\n/**\n * Checks if there is a previous page.\n */\nexport function hasPreviousPage(\n  options: InfiniteQueryPageParamsOptions<any, any>,\n  data?: InfiniteData<unknown>,\n): boolean {\n  if (!data || !options.getPreviousPageParam) return false\n  return getPreviousPageParam(options, data) != null\n}\n","import {\n  functionalUpdate,\n  hashKey,\n  hashQueryKeyByOptions,\n  noop,\n  partialMatchKey,\n  resolveStaleTime,\n  skipToken,\n} from './utils'\nimport { QueryCache } from './queryCache'\nimport { MutationCache } from './mutationCache'\nimport { focusManager } from './focusManager'\nimport { onlineManager } from './onlineManager'\nimport { notifyManager } from './notifyManager'\nimport { infiniteQueryBehavior } from './infiniteQueryBehavior'\nimport type {\n  CancelOptions,\n  DefaultError,\n  DefaultOptions,\n  DefaultedQueryObserverOptions,\n  EnsureInfiniteQueryDataOptions,\n  EnsureQueryDataOptions,\n  FetchInfiniteQueryOptions,\n  FetchQueryOptions,\n  InferDataFromTag,\n  InferErrorFromTag,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  MutationKey,\n  MutationObserverOptions,\n  MutationOptions,\n  NoInfer,\n  OmitKeyof,\n  QueryClientConfig,\n  QueryKey,\n  QueryObserverOptions,\n  QueryOptions,\n  RefetchOptions,\n  RefetchQueryFilters,\n  ResetOptions,\n  SetDataOptions,\n} from './types'\nimport type { QueryState } from './query'\nimport type { MutationFilters, QueryFilters, Updater } from './utils'\n\n// TYPES\n\ninterface QueryDefaults {\n  queryKey: QueryKey\n  defaultOptions: OmitKeyof<QueryOptions<any, any, any>, 'queryKey'>\n}\n\ninterface MutationDefaults {\n  mutationKey: MutationKey\n  defaultOptions: MutationOptions<any, any, any, any>\n}\n\n// CLASS\n\nexport class QueryClient {\n  #queryCache: QueryCache\n  #mutationCache: MutationCache\n  #defaultOptions: DefaultOptions\n  #queryDefaults: Map<string, QueryDefaults>\n  #mutationDefaults: Map<string, MutationDefaults>\n  #mountCount: number\n  #unsubscribeFocus?: () => void\n  #unsubscribeOnline?: () => void\n\n  constructor(config: QueryClientConfig = {}) {\n    this.#queryCache = config.queryCache || new QueryCache()\n    this.#mutationCache = config.mutationCache || new MutationCache()\n    this.#defaultOptions = config.defaultOptions || {}\n    this.#queryDefaults = new Map()\n    this.#mutationDefaults = new Map()\n    this.#mountCount = 0\n  }\n\n  mount(): void {\n    this.#mountCount++\n    if (this.#mountCount !== 1) return\n\n    this.#unsubscribeFocus = focusManager.subscribe(async (focused) => {\n      if (focused) {\n        await this.resumePausedMutations()\n        this.#queryCache.onFocus()\n      }\n    })\n    this.#unsubscribeOnline = onlineManager.subscribe(async (online) => {\n      if (online) {\n        await this.resumePausedMutations()\n        this.#queryCache.onOnline()\n      }\n    })\n  }\n\n  unmount(): void {\n    this.#mountCount--\n    if (this.#mountCount !== 0) return\n\n    this.#unsubscribeFocus?.()\n    this.#unsubscribeFocus = undefined\n\n    this.#unsubscribeOnline?.()\n    this.#unsubscribeOnline = undefined\n  }\n\n  isFetching<\n    TQueryFilters extends QueryFilters<any, any, any, any> = QueryFilters,\n  >(filters?: TQueryFilters): number {\n    return this.#queryCache.findAll({ ...filters, fetchStatus: 'fetching' })\n      .length\n  }\n\n  isMutating<\n    TMutationFilters extends MutationFilters<any, any> = MutationFilters,\n  >(filters?: TMutationFilters): number {\n    return this.#mutationCache.findAll({ ...filters, status: 'pending' }).length\n  }\n\n  /**\n   * Imperative (non-reactive) way to retrieve data for a QueryKey.\n   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.\n   *\n   * Hint: Do not use this function inside a component, because it won't receive updates.\n   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.\n   */\n  getQueryData<\n    TQueryFnData = unknown,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n  >(queryKey: TTaggedQueryKey): TInferredQueryFnData | undefined {\n    const options = this.defaultQueryOptions({ queryKey })\n\n    return this.#queryCache.get(options.queryHash)?.state.data as\n      | TInferredQueryFnData\n      | undefined\n  }\n\n  ensureQueryData<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: EnsureQueryDataOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<TData> {\n    const defaultedOptions = this.defaultQueryOptions(options)\n    const query = this.#queryCache.build(this, defaultedOptions)\n    const cachedData = query.state.data\n\n    if (cachedData === undefined) {\n      return this.fetchQuery(options)\n    }\n\n    if (\n      options.revalidateIfStale &&\n      query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))\n    ) {\n      void this.prefetchQuery(defaultedOptions)\n    }\n\n    return Promise.resolve(cachedData)\n  }\n\n  getQueriesData<\n    TQueryFnData = unknown,\n    TQueryFilters extends QueryFilters<\n      any,\n      any,\n      any,\n      any\n    > = QueryFilters<TQueryFnData>,\n    TInferredQueryFnData = TQueryFilters extends QueryFilters<\n      infer TData,\n      any,\n      any,\n      any\n    >\n      ? TData\n      : TQueryFnData,\n  >(\n    filters: TQueryFilters,\n  ): Array<[QueryKey, TInferredQueryFnData | undefined]> {\n    return this.#queryCache.findAll(filters).map(({ queryKey, state }) => {\n      const data = state.data as TInferredQueryFnData | undefined\n      return [queryKey, data]\n    })\n  }\n\n  setQueryData<\n    TQueryFnData = unknown,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n  >(\n    queryKey: TTaggedQueryKey,\n    updater: Updater<\n      NoInfer<TInferredQueryFnData> | undefined,\n      NoInfer<TInferredQueryFnData> | undefined\n    >,\n    options?: SetDataOptions,\n  ): TInferredQueryFnData | undefined {\n    const defaultedOptions = this.defaultQueryOptions<\n      any,\n      any,\n      unknown,\n      any,\n      QueryKey\n    >({ queryKey })\n\n    const query = this.#queryCache.get<TInferredQueryFnData>(\n      defaultedOptions.queryHash,\n    )\n    const prevData = query?.state.data\n    const data = functionalUpdate(updater, prevData)\n\n    if (data === undefined) {\n      return undefined\n    }\n\n    return this.#queryCache\n      .build(this, defaultedOptions)\n      .setData(data, { ...options, manual: true })\n  }\n\n  setQueriesData<\n    TQueryFnData,\n    TQueryFilters extends QueryFilters<\n      any,\n      any,\n      any,\n      any\n    > = QueryFilters<TQueryFnData>,\n    TInferredQueryFnData = TQueryFilters extends QueryFilters<\n      infer TData,\n      any,\n      any,\n      any\n    >\n      ? TData\n      : TQueryFnData,\n  >(\n    filters: TQueryFilters,\n    updater: Updater<\n      NoInfer<TInferredQueryFnData> | undefined,\n      NoInfer<TInferredQueryFnData> | undefined\n    >,\n    options?: SetDataOptions,\n  ): Array<[QueryKey, TInferredQueryFnData | undefined]> {\n    return notifyManager.batch(() =>\n      this.#queryCache\n        .findAll(filters)\n        .map(({ queryKey }) => [\n          queryKey,\n          this.setQueryData<TInferredQueryFnData>(queryKey, updater, options),\n        ]),\n    )\n  }\n\n  getQueryState<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n    TInferredError = InferErrorFromTag<TError, TTaggedQueryKey>,\n  >(\n    queryKey: TTaggedQueryKey,\n  ): QueryState<TInferredQueryFnData, TInferredError> | undefined {\n    const options = this.defaultQueryOptions({ queryKey })\n    return this.#queryCache.get<TInferredQueryFnData, TInferredError>(\n      options.queryHash,\n    )?.state\n  }\n\n  removeQueries<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n    TInferredError = InferErrorFromTag<TError, TTaggedQueryKey>,\n  >(\n    filters?: QueryFilters<\n      TInferredQueryFnData,\n      TInferredError,\n      TInferredQueryFnData,\n      TTaggedQueryKey\n    >,\n  ): void {\n    const queryCache = this.#queryCache\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        queryCache.remove(query)\n      })\n    })\n  }\n\n  resetQueries<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n    TInferredError = InferErrorFromTag<TError, TTaggedQueryKey>,\n  >(\n    filters?: QueryFilters<\n      TInferredQueryFnData,\n      TInferredError,\n      TInferredQueryFnData,\n      TTaggedQueryKey\n    >,\n    options?: ResetOptions,\n  ): Promise<void> {\n    const queryCache = this.#queryCache\n\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        query.reset()\n      })\n      return this.refetchQueries(\n        {\n          type: 'active',\n          ...filters,\n        },\n        options,\n      )\n    })\n  }\n\n  cancelQueries<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n    TInferredError = InferErrorFromTag<TError, TTaggedQueryKey>,\n  >(\n    filters?: QueryFilters<\n      TInferredQueryFnData,\n      TInferredError,\n      TInferredQueryFnData,\n      TTaggedQueryKey\n    >,\n    cancelOptions: CancelOptions = {},\n  ): Promise<void> {\n    const defaultedCancelOptions = { revert: true, ...cancelOptions }\n\n    const promises = notifyManager.batch(() =>\n      this.#queryCache\n        .findAll(filters)\n        .map((query) => query.cancel(defaultedCancelOptions)),\n    )\n\n    return Promise.all(promises).then(noop).catch(noop)\n  }\n\n  invalidateQueries<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n    TInferredError = InferErrorFromTag<TError, TTaggedQueryKey>,\n  >(\n    filters?: InvalidateQueryFilters<\n      TInferredQueryFnData,\n      TInferredError,\n      TInferredQueryFnData,\n      TTaggedQueryKey\n    >,\n    options: InvalidateOptions = {},\n  ): Promise<void> {\n    return notifyManager.batch(() => {\n      this.#queryCache.findAll(filters).forEach((query) => {\n        query.invalidate()\n      })\n\n      if (filters?.refetchType === 'none') {\n        return Promise.resolve()\n      }\n      return this.refetchQueries(\n        {\n          ...filters,\n          type: filters?.refetchType ?? filters?.type ?? 'active',\n        },\n        options,\n      )\n    })\n  }\n\n  refetchQueries<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TTaggedQueryKey extends QueryKey = QueryKey,\n    TInferredQueryFnData = InferDataFromTag<TQueryFnData, TTaggedQueryKey>,\n    TInferredError = InferErrorFromTag<TError, TTaggedQueryKey>,\n  >(\n    filters?: RefetchQueryFilters<\n      TInferredQueryFnData,\n      TInferredError,\n      TInferredQueryFnData,\n      TTaggedQueryKey\n    >,\n    options: RefetchOptions = {},\n  ): Promise<void> {\n    const fetchOptions = {\n      ...options,\n      cancelRefetch: options.cancelRefetch ?? true,\n    }\n    const promises = notifyManager.batch(() =>\n      this.#queryCache\n        .findAll(filters)\n        .filter((query) => !query.isDisabled())\n        .map((query) => {\n          let promise = query.fetch(undefined, fetchOptions)\n          if (!fetchOptions.throwOnError) {\n            promise = promise.catch(noop)\n          }\n          return query.state.fetchStatus === 'paused'\n            ? Promise.resolve()\n            : promise\n        }),\n    )\n\n    return Promise.all(promises).then(noop)\n  }\n\n  fetchQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = never,\n  >(\n    options: FetchQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<TData> {\n    const defaultedOptions = this.defaultQueryOptions(options)\n\n    // https://github.com/tannerlinsley/react-query/issues/652\n    if (defaultedOptions.retry === undefined) {\n      defaultedOptions.retry = false\n    }\n\n    const query = this.#queryCache.build(this, defaultedOptions)\n\n    return query.isStaleByTime(\n      resolveStaleTime(defaultedOptions.staleTime, query),\n    )\n      ? query.fetch(defaultedOptions)\n      : Promise.resolve(query.state.data as TData)\n  }\n\n  prefetchQuery<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n  >(\n    options: FetchQueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): Promise<void> {\n    return this.fetchQuery(options).then(noop).catch(noop)\n  }\n\n  fetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: FetchInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<InfiniteData<TData, TPageParam>> {\n    options.behavior = infiniteQueryBehavior<\n      TQueryFnData,\n      TError,\n      TData,\n      TPageParam\n    >(options.pages)\n    return this.fetchQuery(options as any)\n  }\n\n  prefetchInfiniteQuery<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: FetchInfiniteQueryOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<void> {\n    return this.fetchInfiniteQuery(options).then(noop).catch(noop)\n  }\n\n  ensureInfiniteQueryData<\n    TQueryFnData,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = unknown,\n  >(\n    options: EnsureInfiniteQueryDataOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryKey,\n      TPageParam\n    >,\n  ): Promise<InfiniteData<TData, TPageParam>> {\n    options.behavior = infiniteQueryBehavior<\n      TQueryFnData,\n      TError,\n      TData,\n      TPageParam\n    >(options.pages)\n\n    return this.ensureQueryData(options as any)\n  }\n\n  resumePausedMutations(): Promise<unknown> {\n    if (onlineManager.isOnline()) {\n      return this.#mutationCache.resumePausedMutations()\n    }\n    return Promise.resolve()\n  }\n\n  getQueryCache(): QueryCache {\n    return this.#queryCache\n  }\n\n  getMutationCache(): MutationCache {\n    return this.#mutationCache\n  }\n\n  getDefaultOptions(): DefaultOptions {\n    return this.#defaultOptions\n  }\n\n  setDefaultOptions(options: DefaultOptions): void {\n    this.#defaultOptions = options\n  }\n\n  setQueryDefaults<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryData = TQueryFnData,\n  >(\n    queryKey: QueryKey,\n    options: Partial<\n      OmitKeyof<\n        QueryObserverOptions<TQueryFnData, TError, TData, TQueryData>,\n        'queryKey'\n      >\n    >,\n  ): void {\n    this.#queryDefaults.set(hashKey(queryKey), {\n      queryKey,\n      defaultOptions: options,\n    })\n  }\n\n  getQueryDefaults(\n    queryKey: QueryKey,\n  ): OmitKeyof<QueryObserverOptions<any, any, any, any, any>, 'queryKey'> {\n    const defaults = [...this.#queryDefaults.values()]\n\n    const result: OmitKeyof<\n      QueryObserverOptions<any, any, any, any, any>,\n      'queryKey'\n    > = {}\n\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(queryKey, queryDefault.queryKey)) {\n        Object.assign(result, queryDefault.defaultOptions)\n      }\n    })\n    return result\n  }\n\n  setMutationDefaults<\n    TData = unknown,\n    TError = DefaultError,\n    TVariables = void,\n    TContext = unknown,\n  >(\n    mutationKey: MutationKey,\n    options: OmitKeyof<\n      MutationObserverOptions<TData, TError, TVariables, TContext>,\n      'mutationKey'\n    >,\n  ): void {\n    this.#mutationDefaults.set(hashKey(mutationKey), {\n      mutationKey,\n      defaultOptions: options,\n    })\n  }\n\n  getMutationDefaults(\n    mutationKey: MutationKey,\n  ): OmitKeyof<MutationObserverOptions<any, any, any, any>, 'mutationKey'> {\n    const defaults = [...this.#mutationDefaults.values()]\n\n    const result: OmitKeyof<\n      MutationObserverOptions<any, any, any, any>,\n      'mutationKey'\n    > = {}\n\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {\n        Object.assign(result, queryDefault.defaultOptions)\n      }\n    })\n\n    return result\n  }\n\n  defaultQueryOptions<\n    TQueryFnData = unknown,\n    TError = DefaultError,\n    TData = TQueryFnData,\n    TQueryData = TQueryFnData,\n    TQueryKey extends QueryKey = QueryKey,\n    TPageParam = never,\n  >(\n    options:\n      | QueryObserverOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryData,\n          TQueryKey,\n          TPageParam\n        >\n      | DefaultedQueryObserverOptions<\n          TQueryFnData,\n          TError,\n          TData,\n          TQueryData,\n          TQueryKey\n        >,\n  ): DefaultedQueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  > {\n    if (options._defaulted) {\n      return options as DefaultedQueryObserverOptions<\n        TQueryFnData,\n        TError,\n        TData,\n        TQueryData,\n        TQueryKey\n      >\n    }\n\n    const defaultedOptions = {\n      ...this.#defaultOptions.queries,\n      ...this.getQueryDefaults(options.queryKey),\n      ...options,\n      _defaulted: true,\n    }\n\n    if (!defaultedOptions.queryHash) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(\n        defaultedOptions.queryKey,\n        defaultedOptions,\n      )\n    }\n\n    // dependent default values\n    if (defaultedOptions.refetchOnReconnect === undefined) {\n      defaultedOptions.refetchOnReconnect =\n        defaultedOptions.networkMode !== 'always'\n    }\n    if (defaultedOptions.throwOnError === undefined) {\n      defaultedOptions.throwOnError = !!defaultedOptions.suspense\n    }\n\n    if (!defaultedOptions.networkMode && defaultedOptions.persister) {\n      defaultedOptions.networkMode = 'offlineFirst'\n    }\n\n    if (defaultedOptions.queryFn === skipToken) {\n      defaultedOptions.enabled = false\n    }\n\n    return defaultedOptions as DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >\n  }\n\n  defaultMutationOptions<T extends MutationOptions<any, any, any, any>>(\n    options?: T,\n  ): T {\n    if (options?._defaulted) {\n      return options\n    }\n    return {\n      ...this.#defaultOptions.mutations,\n      ...(options?.mutationKey &&\n        this.getMutationDefaults(options.mutationKey)),\n      ...options,\n      _defaulted: true,\n    } as T\n  }\n\n  clear(): void {\n    this.#queryCache.clear()\n    this.#mutationCache.clear()\n  }\n}\n"],"names":["isServer","window","globalThis","noop","resolveStaleTime","staleTime","query","matchQuery","filters","type","exact","fetchStatus","predicate","queryKey","stale","queryHash","hashQueryKeyByOptions","options","partialMatchKey","isActive","isStale","state","matchMutation","mutation","status","mutationKey","hashKey","queryKeyHashFn","JSON","stringify","_","val","isPlainObject","Object","keys","sort","reduce","result","key","a","b","every","replaceEqualDeep","array","isPlainArray","aItems","aSize","length","bItems","bSize","copy","equalItems","i","includes","value","Array","isArray","o","hasObjectPrototype","ctor","constructor","prot","prototype","hasOwnProperty","getPrototypeOf","toString","call","replaceData","prevData","data","structuralSharing","addToEnd","items","item","max","arguments","undefined","newItems","slice","addToStart","skipToken","Symbol","ensureQueryFn","fetchOptions","queryFn","initialPromise","Promise","reject","Error","defaultScheduler","cb","setTimeout","notifyManager","queue","transactions","notifyFn","callback","batchNotifyFn","scheduleFn","schedule","push","batch","flush","originalQueue","forEach","batchCalls","_len","args","_key","setNotifyFunction","fn","setBatchNotifyFunction","setScheduler","createNotifyManager","Subscribable","listeners","Set","this","subscribe","bind","listener","add","onSubscribe","delete","onUnsubscribe","hasListeners","size","focusManager","super","onFocus","addEventListener","removeEventListener","setEventListener","setup","focused","setFocused","isFocused","document","visibilityState","onlineManager","onOnline","onlineListener","offlineListener","setOnline","online","isOnline","defaultRetryDelay","failureCount","Math","min","canFetch","networkMode","CancelledError","revert","silent","isCancelledError","createRetryer","config","continueFn","isRetryCancelled","isResolved","thenable","resolve","_resolve","_reject","finalize","assign","catch","reason","pendingThenable","canContinue","canRun","canStart","onSuccess","onError","pause","continueResolve","onPause","then","onContinue","run","promiseOrValue","error","retry","retryDelay","delay","shouldRetry","timeout","onFail","promise","cancel","cancelOptions","abort","continue","cancelRetry","continueRetry","start","Removable","destroy","clearGcTimeout","scheduleGc","gcTime","Infinity","optionalRemove","updateGcTime","newGcTime","clearTimeout","Query","defaultOptions","setOptions","observers","client","getQueryCache","initialData","hasData","initialDataUpdatedAt","dataUpdateCount","dataUpdatedAt","Date","now","errorUpdateCount","errorUpdatedAt","fetchFailureCount","fetchFailureReason","fetchMeta","isInvalidated","getDefaultState","meta","remove","setData","newData","updatedAt","manual","setState","setStateOptions","reset","some","observer","resolveEnabled","enabled","isDisabled","getObserversCount","getCurrentResult","isStaleByTime","timeUntilStale","find","x","shouldFetchOnWindowFocus","refetch","cancelRefetch","shouldFetchOnReconnect","addObserver","notify","removeObserver","filter","invalidate","fetch","abortController","AbortController","addSignalProperty","object","defineProperty","enumerable","get","signal","context","fetchFn","queryFnContext","persister","behavior","onFetch","onSettled","action","reducer","onQueryUpdate","QueryCache","Map","build","defaultQueryOptions","getQueryDefaults","has","set","queryInMap","clear","getAll","values","defaultedFilters","findAll","queries","event","Mutation","mutationId","mutationCache","failureReason","isPaused","variables","submittedAt","execute","mutationFn","restored","onMutate","runNext","onMutationUpdate","MutationCache","defaultMutationOptions","scope","scopeFor","scopedMutations","index","indexOf","splice","mutationsWithSameScope","firstPendingMutation","m","foundMutation","from","resumePausedMutations","pausedMutations","all","map","id","infiniteQueryBehavior","pages","direction","fetchMore","oldPages","oldPageParams","pageParams","currentPage","async","cancelled","fetchPage","param","previous","pageParam","aborted","page","maxPages","addTo","oldData","getPreviousPageParam","getNextPageParam","remainingPages","initialPageParam","_ref","lastIndex","_ref2","QueryClient","queryCache","mount","unmount","isFetching","isMutating","getQueryData","ensureQueryData","defaultedOptions","cachedData","fetchQuery","revalidateIfStale","prefetchQuery","getQueriesData","setQueryData","updater","input","functionalUpdate","setQueriesData","getQueryState","removeQueries","resetQueries","refetchQueries","cancelQueries","defaultedCancelOptions","promises","invalidateQueries","refetchType","throwOnError","fetchInfiniteQuery","prefetchInfiniteQuery","ensureInfiniteQueryData","getMutationCache","getDefaultOptions","setDefaultOptions","setQueryDefaults","defaults","queryDefault","setMutationDefaults","getMutationDefaults","_defaulted","refetchOnReconnect","suspense","mutations"],"sourceRoot":""}